# 35 - 工厂模式 🏭

> **难度**: ⭐⭐⭐ | **价值**: 🔥🔥🔥🔥 | **创新度**: ⭐⭐⭐⭐ |

---

## 📌 技术概述

### 核心概念/问题背景

工厂模式是一种创建型设计模式，它定义了一个创建对象的接口，但由子类决定要实例化的类。工厂方法让类推迟到子类进行实例化。

在山西文旅智能体项目中，我们使用工厂模式来创建不同类型的数据服务（Mock服务 vs 真实服务），实现了服务层的灵活切换，便于开发测试和生产部署。

### 技术成果/数据

| 指标 | 数据 | 说明 |
|------|------|------|
| 工厂方法 | 1个 | get_data_service() |
| 产品类 | 3个 | DataServiceBase, MockDataService, RealDataService |
| 切换方式 | 配置驱动 | DATA_SOURCE环境变量 |
| 使用场景 | 全局API | 所有API端点 |

---

## 🔍 技术原理

### 核心原理/算法设计

工厂模式基于以下核心原则：

1. **定义产品接口**
   - 抽象基类 DataServiceBase
   - 统一的方法签名

2. **实现具体产品**
   - MockDataService：模拟数据服务
   - RealDataService：真实数据服务

3. **工厂方法**
   - get_data_service()
   - 根据配置返回具体实例

### 技术方案/架构

```
┌─────────────────────────────────────────────────────┐
│               工厂模式架构                             │
├─────────────────────────────────────────────────────┤
│                                                     │
│  抽象基类 (DataServiceBase)                           │
│       │                                             │
│       ├── get_attractions()                          │
│       ├── get_attraction_detail()                  │
│       ├── chat()                                    │
│       ├── plan_itinerary()                          │
│       └── ... (统一接口)                             │
│       │                                             │
│       △                                              │
│       ├─────────────────────┬──────────────────────┐ │
│       △                     △                       │ │
│  MockDataService         RealDataService              │ │
│  (模拟数据服务)           (真实数据服务)               │ │
│       │                     │                       │ │
│       ├── 返回模拟数据       ├── 调用真实LLM        │ │
│       ├── 快速响应           ├── 查询真实数据库      │ │
│       └── 开发测试           └── 生产环境使用        │ │
│                                                     │
│  工厂函数 (get_data_service)                        │
│       │                                             │
│       ├── 根据配置 (DATA_SOURCE)                     │
│       ├── 创建服务实例                               │
│       └── 返回基类引用                               │
│                                                     │
└─────────────────────────────────────────────────────┘
```

---

## 💡 项目应用

### 代码位置

**核心文件：**
- 服务工厂：[backend/app/services/factory.py](../../backend/app/services/factory.py#L1-L35)
- 基类定义：[backend/app/services/base_service.py](../../backend/app/services/base_service.py)
- Mock服务：[backend/app/services/mock_service.py](../../backend/app/services/mock_service.py)

### 实现细节

#### 1. 抽象基类定义

```python
# backend/app/services/base_service.py
from abc import ABC, abstractmethod
from typing import Optional, List, Dict, Any

class DataServiceBase(ABC):
    """数据服务基类"""

    def __init__(self):
        self.source_type = "base"

    # 游客端接口
    @abstractmethod
    async def get_attractions(self, city: Optional[str] = None, tags: Optional[List[str]] = None, limit: int = 20) -> List[Dict]:
        """获取景点列表"""
        pass

    @abstractmethod
    async def chat(self, message: str, session_id: Optional[str] = None, context: Optional[Dict] = None) -> Dict:
        """智能对话"""
        pass

    # ... 更多抽象方法
```

#### 2. 工厂方法

```python
# backend/app/services/factory.py:12-31
def get_data_service(source: Optional[str] = None) -> DataServiceBase:
    """
    获取数据服务实例

    Args:
        source: 数据源类型（"mock" 或 "real"）
               如果为None，则使用配置文件中的设置

    Returns:
        DataServiceBase: 数据服务实例
    """
    # 如果指定了source，使用指定的；否则使用配置文件
    data_source = source or settings.DATA_SOURCE

    if data_source == "real":
        return RealDataService()
    else:
        # 默认返回mock服务
        return MockDataService()


# 全局数据服务实例（使用默认配置）
default_data_service = get_data_service()
```

#### 3. 具体产品实现

```python
# backend/app/services/mock_service.py
class MockDataService(DataServiceBase):
    """模拟数据服务实现"""

    def __init__(self):
        super().__init__()
        self.source_type = "mock"

    async def get_attractions(self, city, tags, limit):
        """返回模拟景点数据"""
        # ... 返回模拟数据

    async def chat(self, message, session_id, context):
        """基于规则的对话"""
        # ... 返回模拟对话响应


# backend/app/services/real_service.py
class RealDataService(DataServiceBase):
    """真实数据服务实现"""

    def __init__(self):
        super().__init__()
        self.source_type = "real"
        self._fallback = MockDataService()  # 降级到Mock服务

        # 初始化LLM客户端
        self._init_llm_client()

    async def chat(self, message, session_id, context):
        """使用真实LLM API"""
        try:
            response = await self._llm_client.chat_with_suggestions(
                message=message,
                history=history
            )
            return response
        except Exception as e:
            # 降级到Mock服务
            return await self._fallback.chat(message, session_id, context)
```

#### 4. API端点使用

```python
# backend/app/api/v1/tourist.py
@router.get("/attractions", response_model=ApiResponse[list])
async def get_attractions(
    city: Optional[str] = None,
    source: Optional[str] = None
):
    """获取景点列表"""
    # 使用工厂获取服务实例
    service = get_data_service(source)

    # 调用服务方法（多态）
    attractions = await service.get_attractions(city, tags, limit)

    return ApiResponse[list](
        success=True,
        data=attractions,
        message=f"获取到{len(attractions)}个景点",
        meta={"data_source": service.source_type}  # 标记数据来源
    )
```

### 核心代码示例

```python
"""
工厂模式完整示例
"""
from abc import ABC, abstractmethod
from typing import Optional

# 1. 抽象产品接口
class DataService(ABC):
    """数据服务接口"""

    @abstractmethod
    async def get_data(self) -> dict:
        """获取数据"""
        pass

    @property
    @abstractmethod
    def source_type(self) -> str:
        """数据源类型"""
        pass


# 2. 具体产品实现
class MockDataService(DataService):
    """模拟数据服务"""

    def __init__(self):
        self._source_type = "mock"

    async def get_data(self) -> dict:
        return {"data": "mock_data", "source": "mock"}

    @property
    def source_type(self) -> str:
        return self._source_type


class RealDataService(DataService):
    """真实数据服务"""

    def __init__(self):
        self._source_type = "real"

    async def get_data(self) -> dict:
        # 连接真实API
        return {"data": "real_data", "source": "real"}

    @property
    def source_type(self) -> str:
        return self._source_type


# 3. 工厂类
class DataServiceFactory:
    """数据服务工厂"""

    @staticmethod
    def create_service(service_type: str) -> DataService:
        """创建服务实例"""
        services = {
            "mock": MockDataService,
            "real": RealDataService
        }

        service_class = services.get(service_type)
        if service_class is None:
            raise ValueError(f"Unknown service type: {service_type}")

        return service_class()


# 4. 使用示例
class ApplicationController:
    """应用控制器"""

    def __init__(self):
        self.factory = DataServiceFactory()

    async def handle_request(self, source: str):
        """处理请求"""
        # 使用工厂创建服务
        service = self.factory.create_service(source)

        # 调用服务（多态）
        data = await service.get_data()

        return {
            "result": data,
            "source": service.source_type
        }


# 使用
controller = ApplicationController()
result = await controller.handle_request("mock")
```

---

## 🎯 演示话术

### 开场介绍（30秒）

```
"各位评委老师，我们使用工厂模式实现了数据服务的灵活切换。

前端可以通过参数指定使用Mock数据还是真实数据，
这极大地方便了开发和演示。"
```

### 深度讲解（2分钟）

```
"工厂模式的核心价值在于解耦。

**传统方式**是直接在代码中创建服务实例，
这样切换数据源需要修改代码。

**使用工厂模式**后，
我们通过工厂函数 `get_data_service()` 创建实例，
只需要传入参数 'mock' 或 'real'，
就能得到相应的服务实例。

**实现方式**：
1. 定义抽象基类 DataServiceBase
2. 两个具体服务类继承基类
3. 工厂函数根据配置返回实例

**好处**：
- 开发时用Mock服务，快速响应
- 演示时用Mock服务，稳定可靠
- 生产时用Real服务，接入真实API

而且Mock和Real实现了相同的接口，
可以无缝切换，
客户端代码完全不需要修改。

这种设计让我们的系统既适合演示，
也能快速接入真实数据。"
```

### 演示互动（1分钟）

```
[操作演示]

1. 展示数据源切换
   "大家请看页面右上角的数据源切换器，
    点击选择'真实数据'，
    后端就会自动使用RealDataService。"

2. 展示响应元数据
   "API响应中的meta字段会标记数据来源，
    这样前端和用户都知道数据的类型。"

3. 展示降级机制
   "即使Real服务出错，
    也会自动降级到Mock服务，
    保证功能始终可用。"
```

### 总结强调（30秒）

```
"通过工厂模式，我们实现了：
- 灵活的数据源切换
- 开发/生产环境隔离
- 优雅的降级机制
- 零修改客户端代码

这充分体现了我们架构设计的专业性。"
```

---

## 📊 对比优势

### 与直接实例化对比

| 维度 | 直接实例化 | 工厂模式 |
|-----|-----------|---------|
| 灵活性 | 低 | 高 |
| 可扩展性 | ⭐⭐ | ⭐⭐⭐⭐⭐ |
| 切换成本 | 高 | 低 |
| 代码复用 | ⭐⭐ | ⭐⭐⭐⭐⭐ |

### 设计模式价值

| 特性 | 本项目 | 其他方案 |
|:----|:-----:|:--------:|
| 解耦程度 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |
| 可测试性 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |

---

## 🚀 应用场景/扩展性

### 应用场景

1. **多数据源**
   - 开发数据 vs 生产数据
   - 不同供应商API
   - A/B测试数据源

2. **环境隔离**
   - 开发环境
   - 测试环境
   - 生产环境

3. **功能降级**
   - 主服务故障
   - 备用服务启用
   - 保证可用性

### 扩展性

工厂模式可扩展到：
- **多工厂模式**：不同类型的工厂
- **抽象工厂**：创建产品族
- **简单工厂**：简化工厂方法

---

## 🏆 总结

### 核心价值

1. **灵活性**: ⭐⭐⭐⭐⭐
   - 按需创建实例

2. **可扩展性**: ⭐⭐⭐⭐⭐
   - 易于添加新类型

3. **解耦性**: ⭐⭐⭐⭐⭐
   - 客户端与服务解耦

4. **可测试性**: ⭐⭐⭐⭐⭐
   - 便于单元测试

### 演示建议

- **最佳展示位置**: 架构设计讲解环节
- **演示时长**: 1.5 分钟
- **关键话术**: "工厂模式，灵活切换"
- **视觉冲击**: 展示数据源切换的流畅效果

---

**文档版本**: v1.0
**最后更新**: 2026-01-02
**作者**: 山西文旅智能体团队
