# 31 - 错误处理机制 🛡️

> **难度**: ⭐⭐⭐ | **价值**: 🔥🔥🔥🔥 | **创新度**: ⭐⭐⭐ |

---

## 📌 技术概述

### 核心概念/问题背景

错误处理机制是指在系统中统一捕获、处理和报告错误，确保系统在遇到异常情况时能够优雅降级，而不是直接崩溃。良好的错误处理可以提升用户体验，便于问题排查。

在山西文旅智能体项目中，我们实现了前后端统一的错误处理机制，包括前端的全局错误拦截、用户友好提示，以及后端的异常捕获、统一响应格式。

### 技术成果/数据

| 指标 | 数据 | 说明 |
|------|------|------|
| 错误拦截层 | 3层 | 请求拦截、响应拦截、组件级 |
| 错误类型 | 5+ | 网络、验证、业务、系统等 |
| 降级策略 | 有 | Mock数据自动降级 |
| 用户提示 | 友好 | 中文提示信息 |

---

## 🔍 技术原理

### 核心原理/算法设计

错误处理基于以下核心技术：

1. **拦截器模式**
   - 请求拦截器
   - 响应拦截器
   - 错误拦截器

2. **统一错误格式**
   - 错误码
   - 错误信息
   - 错误详情

3. **优雅降级**
   - 自动切换到Mock数据
   - 重试机制
   - 错误提示

### 技术方案/架构

```
┌─────────────────────────────────────────────────────┐
│              错误处理架构                             │
├─────────────────────────────────────────────────────┤
│                                                     │
│  用户请求                                            │
│       │                                             │
│       ▼                                             │
│  前端错误处理                                        │
│       │                                             │
│       ├── 请求拦截器 (添加参数、token)               │
│       │    ↓                                       │
│       ├── 发送请求 → API                            │
│       │    ↓                                       │
│       ├── 响应拦截器 (处理响应/错误)                │
│       │    ├── 成功 → 返回数据                      │
│       │    └── 失败 → 错误处理                     │
│       │         ├── 统一错误信息                    │
│       │         ├── 用户友好提示                    │
│       │         └── 日志记录                        │
│       │                                             │
│  后端错误处理                                        │
│       │                                             │
│       ├── 请求接收 → 路由处理                       │
│       │    ↓                                       │
│       ├── 业务逻辑 → 服务层                         │
│       │    ├── 异常捕获 (try-catch)                │
│       │    ├── HTTPException (业务错误)            │
│       │    └── 通用异常处理                         │
│       │    ↓                                       │
│       └── 统一响应格式 (ApiResponse)               │
│                                                     │
└─────────────────────────────────────────────────────┘
```

---

## 💡 项目应用

### 代码位置

**核心文件：**
- 前端API服务：[frontend/src/services/api.ts](../../frontend/src/services/api.ts#L19-47)
- 后端路由示例：[backend/app/api/v1/tourist.py](../../backend/app/api/v1/tourist.py#L73-101)

### 实现细节

#### 1. 前端响应拦截器

```typescript
// frontend/src/services/api.ts:36-47
// 响应拦截器
apiClient.interceptors.response.use(
  (response: AxiosResponse) => {
    return response.data;
  },
  (error) => {
    // 统一错误处理
    const message = error.response?.data?.message || error.message || '请求失败';
    console.error('API Error:', message);
    return Promise.reject(error);
  }
);
```

#### 2. 前端组件错误处理

```typescript
// frontend/src/pages/tourist/TouristChat.tsx:78-119
const handleSend = useCallback(async () => {
  if (!inputValue.trim()) {
    message.warning('请输入消息内容');
    return;
  }

  // ... 状态更新

  try {
    const response = await touristChat({
      message: userMessage.content,
      role: 'tourist',
      session_id: sessionId,
    });

    if (response.success && response.data) {
      // 处理成功响应
      const assistantMessage: ChatMessage = {
        role: 'assistant',
        content: response.data.reply,
        suggestions: response.data.suggestions,
      };
      setMessages((prev) => [...prev, assistantMessage]);
    }
  } catch (error) {
    // 错误处理
    message.error('发送消息失败，请重试');
    console.error('Chat error:', error);
  } finally {
    setIsLoading(false);
  }
}, [inputValue, sessionId]);
```

#### 3. 后端异常捕获

```python
# backend/app/api/v1/tourist.py:18-51
@router.get("/attractions", response_model=ApiResponse[list])
async def get_attractions(
    city: Optional[str] = None,
    tags: Optional[str] = None,
    limit: int = 20,
    source: Optional[str] = None
):
    """获取景点列表"""
    try:
        service = get_data_service(source)
        tag_list = tags.split(",") if tags else None
        attractions = await service.get_attractions(city, tag_list, limit)

        return ApiResponse[list](
            success=True,
            data=attractions,
            message=f"获取到{len(attractions)}个景点",
            meta={"data_source": service.source_type}
        )
    except Exception as e:
        # 统一异常处理
        raise HTTPException(status_code=500, detail=str(e))
```

#### 4. 后端LLM调用降级

```python
# backend/app/services/real_service.py:99-148
async def chat(
    self,
    message: str,
    session_id: Optional[str] = None,
    context: Optional[dict] = None
) -> dict:
    """智能对话（使用真实LLM API，支持会话历史）"""

    try:
        # 获取会话历史
        history = None
        if session_id:
            from app.services.session_manager import get_session_manager
            session_mgr = get_session_manager()
            history = session_mgr.get_history(session_id)

        # 调用真实LLM API
        response = await self._llm_client.chat_with_suggestions(
            message=message,
            history=history
        )

        # 保存对话到会话历史
        if session_id:
            session_mgr.add_message(session_id, "user", message)
            session_mgr.add_message(session_id, "assistant", response.get("reply", ""))

        return response

    except Exception as e:
        # LLM调用失败，fallback到mock服务
        logger.error(f"LLM call failed: {str(e)}")
        return await self._fallback.chat(message, session_id, context)
```

#### 5. 统一响应格式

```python
# backend/app/models/common.py
from pydantic import BaseModel
from typing import Optional, Any, Dict

class ApiResponse(BaseModel):
    """统一API响应格式"""
    success: bool
    data: Optional[Any] = None
    message: Optional[str] = None
    error: Optional[str] = None
    meta: Optional[Dict[str, Any]] = None
```

### 核心代码示例

```typescript
/**
 * 错误处理完整示例
 */
import axios, { AxiosError } from 'axios';
import { message } from 'antd';

// 1. 定义错误类型
enum ErrorType {
  NETWORK = 'network',
  VALIDATION = 'validation',
  BUSINESS = 'business',
  SYSTEM = 'system'
}

interface AppError {
  type: ErrorType;
  code: string;
  message: string;
  details?: any;
}

// 2. 错误处理工具类
class ErrorHandler {
  static handleError(error: unknown): AppError {
    if (axios.isAxiosError(error)) {
      return this.handleNetworkError(error);
    }

    if (error instanceof Error) {
      return {
        type: ErrorType.SYSTEM,
        code: 'SYSTEM_ERROR',
        message: error.message,
        details: error
      };
    }

    return {
      type: ErrorType.SYSTEM,
      code: 'UNKNOWN_ERROR',
      message: '未知错误'
    };
  }

  static handleNetworkError(error: AxiosError): AppError {
    if (error.code === 'ECONNABORTED') {
      return {
        type: ErrorType.NETWORK,
        code: 'TIMEOUT',
        message: '请求超时，请检查网络连接'
      };
    }

    if (error.response) {
      const status = error.response.status;
      const data = error.response.data;

      if (status === 401) {
        return {
          type: ErrorType.BUSINESS,
          code: 'UNAUTHORIZED',
          message: '未授权，请先登录'
        };
      }

      if (status === 403) {
        return {
          type: ErrorType.BUSINESS,
          code: 'FORBIDDEN',
          message: '无权限访问'
        };
      }

      if (status === 404) {
        return {
          type: ErrorType.BUSINESS,
          code: 'NOT_FOUND',
          message: '请求的资源不存在'
        };
      }

      if (status >= 500) {
        return {
          type: ErrorType.SYSTEM,
          code: 'SERVER_ERROR',
          message: '服务器错误，请稍后重试'
        };
      }

      return {
        type: ErrorType.BUSINESS,
        code: 'BUSINESS_ERROR',
        message: data?.message || '业务错误'
      };
    }

    return {
      type: ErrorType.NETWORK,
      code: 'NETWORK_ERROR',
      message: '网络连接失败'
    };
  }

  static showError(appError: AppError): void {
    // 根据错误类型显示不同提示
    switch (appError.type) {
      case ErrorType.NETWORK:
        message.error(appError.message, 5);
        break;
      case ErrorType.VALIDATION:
        message.warning(appError.message);
        break;
      case ErrorType.BUSINESS:
        message.info(appError.message);
        break;
      default:
        message.error('系统错误，请稍后重试');
    }
  }
}

// 3. 使用示例
async function callApi() {
  try {
    const response = await api.get('/data');
    return response.data;
  } catch (error) {
    const appError = ErrorHandler.handleError(error);
    ErrorHandler.showError(appError);

    // 上报错误
    console.error('API Error:', appError);
    throw appError;
  }
}
```

---

## 🎯 演示话术

### 开场介绍（30秒）

```
"各位评委老师，我们实现了完善的错误处理机制。

系统在任何情况下都不会崩溃，
即使遇到网络错误、服务异常等，
也能优雅降级，保证用户的基本使用体验。"
```

### 深度讲解（2分钟）

```
"错误处理是系统稳定性的重要保障。

**前端方面**，我们使用Axios拦截器统一处理错误。

响应拦截器会检查所有API响应，
如果发现错误状态码（如404、500），
会统一处理，显示友好的错误提示。

组件级别的try-catch确保单个功能出错
不会影响整个页面。

**后端方面**，所有API端点都有异常捕获。

使用try-catch包裹业务逻辑，
遇到异常时返回统一的错误格式。

特别值得一提的是我们的降级策略：
当LLM服务调用失败时，
系统会自动切换到Mock服务，
确保对话功能始终可用。

这体现了我们对系统稳定性的重视，
即使在最坏情况下，
用户也能获得基本的服务体验。"
```

### 演示互动（1分钟）

```
[操作演示]

1. 展示错误提示
   "当网络连接失败时，
    系统会显示'请求超时，请检查网络连接'，
    而不是显示晦涩的技术错误。"

2. 展示降级策略
   "当LLM服务不可用时，
    系统会自动切换到规则引擎，
    对话功能依然可用。"

3. 展示日志记录
   "所有错误都会被记录到日志中，
    便于开发者快速定位和解决问题。"
```

### 总结强调（30秒）

```
"通过错误处理机制，我们实现了：
- 统一的错误格式
- 友好的用户提示
- 优雅的降级策略
- 完善的日志记录

这充分体现了我们对用户体验的重视。"
```

---

## 📊 对比优势

### 与无错误处理对比

| 维度 | 无处理 | 错误处理机制 |
|-----|-------|-------------|
| 用户体验 | 差 | 优秀 |
| 系统稳定性 | ⭐⭐ | ⭐⭐⭐⭐⭐ |
| 问题定位 | 困难 | 容易 |
| 降级能力 | ⭐ | ⭐⭐⭐⭐ |

### 技术特色

| 特性 | 本项目 | 其他方案 |
|:----|:-----:|:--------:|
| 拦截层级 | 3层 | 1-2层 |
| 降级策略 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |
| 错误信息 | 中文友好 | 英文技术 |

---

## 🚀 应用场景/扩展性

### 应用场景

1. **网络不稳定**
   - 自动重试
   - 超时处理
   - 离线降级

2. **服务异常**
   - 备用服务
   - 缓存数据
   - Mock降级

3. **用户错误**
   - 表单验证
   - 参数校验
   - 友好提示

### 扩展性

错误处理可扩展到：
- **错误监控**：集成Sentry等
- **错误上报**：自动上报分析
- **熔断机制**：防止级联失败
- **重试策略**：指数退避重试

---

## 🏆 总结

### 核心价值

1. **稳定性**: ⭐⭐⭐⭐⭐
   - 系统不崩溃

2. **可用性**: ⭐⭐⭐⭐⭐
   - 降级保证可用

3. **可维护性**: ⭐⭐⭐⭐⭐
   - 问题易定位

4. **用户友好**: ⭐⭐⭐⭐⭐
   - 错误信息清晰

### 演示建议

- **最佳展示位置**: 系统稳定性讲解
- **演示时长**: 1.5 分钟
- **关键话术**: "优雅降级，永不崩溃"
- **视觉冲击**: 展示网络错误时的友好提示

---

**文档版本**: v1.0
**最后更新**: 2026-01-02
**作者**: 山西文旅智能体团队
