# 文本切分与检索策略全指南：让RAG准确率突破90%

> 作者：码上云开工
> 视频讲解：短视频平台账号「架构狮与橘」
> 阅读时间：约18分钟
> 难度级别：⭐⭐⭐⭐

## 目录

- [一、为什么文档切分这么重要](#一为什么文档切分这么重要)
- [二、文档切分方法详解](#二文档切分方法详解)
- [三、元数据设计最佳实践](#三元数据设计最佳实践)
- [四、检索策略演进](#四检索策略演进)
- [五、混合检索与Rerank](#五混合检索与rerank)
- [六、生产环境优化](#六生产环境优化)
- [七、总结](#七总结)

---

## 一、为什么文档切分这么重要

### 1.1 切分质量决定效果上界

```
切分质量 = RAG系统效果的上界

切分得好  → 准确率 85%+
切分一般  → 准确率 60-70%
切分得差  → 准确率 <50%
```

### 1.2 切分不当的后果

| 问题 | 影响 | 示例 |
|------|------|------|
| **语义不完整** | AI理解困难 | 句子被截断 |
| **上下文丢失** | 检索效果差 | 段落被拆散 |
| **信息割裂** | 答案不准确 | 相关内容分散在不同chunk |

---

## 二、文档切分方法详解

### 2.1 四种切分方法对比

| 方法 | 原理 | 优点 | 缺点 | 适用场景 | 评分 |
|------|------|------|------|---------|------|
| **固定长度切分** | 按字符数切分 | 简单高效 | 可能截断语义 | 通用文档 | ⭐⭐⭐ |
| **语义切分** | 按段落/章节 | 保持语义完整 | 实现复杂 | 结构化文档 | ⭐⭐⭐⭐⭐ |
| **递归切分** | 多级切分 | 平衡大小和语义 | 需要调参 | 混合文档 | ⭐⭐⭐⭐ |
| **专用切分** | 针对特定格式 | 保留结构 | 适用性窄 | 代码/表格 | ⭐⭐⭐⭐ |

### 2.2 方法1：固定长度切分

**推荐参数：**

```python
chunk_size = 500-1000        # 每块大小
chunk_overlap = 50-200       # 重叠大小
separators = ["\n\n", "\n", "。", " ", ""]
```

**LangChain实现：**

```python
from langchain.text_splitter import RecursiveCharacterTextSplitter

text_splitter = RecursiveCharacterTextSplitter(
    chunk_size=500,
    chunk_overlap=50,
    separators=["\n\n", "\n", "。", " ", ""]
)

chunks = text_splitter.split_text(document)
```

### 2.3 方法2：语义切分

**Markdown文档切分：**

```python
from langchain.text_splitter import MarkdownHeaderTextSplitter

markdown_splitter = MarkdownHeaderTextSplitter(
    headers_to_split_on=[
        ("#", "Header 1"),
        ("##", "Header 2"),
    ]
)

chunks = markdown_splitter.split_text(markdown_document)
```

**效果对比：**

| 方式 | Chunk 1 | Chunk 2 | Chunk 3 |
|------|---------|---------|---------|
| 固定长度 | 第1章前半 | 第1章后半+第2章前半 | 第2章后半+第3章 |
| 语义切分 | 第1章完整 | 第2章完整 | 第3章完整 |

### 2.4 方法3：递归切分

**工作原理：**

```
优先级1: \n\n (段落)
   ↓ 如果失败
优先级2: \n (句子)
   ↓ 如果失败
优先级3: 。 (句号)
   ↓ 如果失败
优先级4: 空格 (字符)
```

### 2.5 方法4：专用切分

**代码切分：**

```python
from langchain.text_splitter import PythonCodeTextSplitter

python_splitter = PythonCodeTextSplitter(
    chunk_size=500,
    chunk_overlap=50
)
chunks = python_splitter.split_text(python_code)
```

---

## 三、元数据设计最佳实践

### 3.1 核心元数据

| 元数据 | 说明 | 示例 | 必要性 |
|--------|------|------|--------|
| **source** | 文档来源 | "产品手册.pdf" | ⭐⭐⭐⭐⭐ |
| **title** | 文档标题 | "Redis分布式锁" | ⭐⭐⭐⭐⭐ |
| **chapter** | 章节 | "第2章" | ⭐⭐⭐⭐ |
| **page** | 页码 | 15 | ⭐⭐⭐ |
| **tags** | 标签 | ["Redis", "锁"] | ⭐⭐⭐⭐ |

### 3.2 实用元数据

| 元数据 | 说明 | 用途 |
|--------|------|------|
| **created_at** | 创建时间 | 时效性过滤 |
| **updated_at** | 更新时间 | 选择最新版本 |
| **category** | 分类 | 类别过滤 |
| **department** | 部门 | 权限控制 |

### 3.3 元数据示例

```json
{
  "text": "SETNX命令可以用来实现分布式锁...",
  "metadata": {
    "source": "Redis技术手册.pdf",
    "title": "Redis分布式锁",
    "chapter": "第2章",
    "section": "2.1 SETNX命令",
    "page": 15,
    "tags": ["Redis", "分布式锁", "SETNX"],
    "date": "2024-01-15"
  }
}
```

---

## 四、检索策略演进

### 4.1 检索策略发展

```
第一代：简单向量检索
   ↓
第二代：Top-K检索
   ↓
第三代：混合检索（向量+关键词）
   ↓
第四代：Rerank重排序
```

### 4.2 策略对比

| 策略 | 准确率 | 召回率 | 延迟 | 复杂度 |
|------|--------|--------|------|--------|
| 简单检索 | 65% | 70% | 20ms | ⭐ |
| Top-K检索 | 78% | 85% | 30ms | ⭐⭐ |
| 混合检索 | 88% | 92% | 80ms | ⭐⭐⭐ |
| 混合+Rerank | 95% | 93% | 200ms | ⭐⭐⭐⭐ |

---

## 五、混合检索与Rerank

### 5.1 混合检索原理

**核心思想：** 向量检索 + 关键词检索

**公式：**

```
最终分数 = α × 向量相似度 + (1-α) × 关键词分数

推荐：α = 0.5（均衡权重）
```

**LangChain实现：**

```python
from langchain.retrievers import EnsembleRetriever
from langchain_community.retrievers import BM25Retriever

# 向量检索器
vector_retriever = vector_db.as_retriever(search_kwargs={"k": 10})

# 关键词检索器
bm25_retriever = BM25Retriever.from_documents(docs, k=10)

# 混合检索器
ensemble_retriever = EnsembleRetriever(
    retrievers=[vector_retriever, bm25_retriever],
    weights=[0.5, 0.5]
)
```

### 5.2 Rerank重排序

**两阶段检索：**

```
阶段1：粗排（召回）
向量检索Top-100（快速）

阶段2：精排（排序）
Rerank模型重新打分
得到Top-10（精确）
```

**BGE-reranker实现：**

```python
from FlagEmbedding import FlagReranker

reranker = FlagReranker(
    'BAAI/bge-reranker-large',
    use_fp16=True
)

# 粗排
candidates = vector_search(query, top_k=100)

# 精排
scores = reranker.compute_score(
    [[query, doc] for doc in candidates]
)

# 排序
top_10 = sorted(
    zip(candidates, scores),
    key=lambda x: x[1],
    reverse=True
)[:10]
```

**效果提升：**

| 场景 | 无Rerank | 有Rerank | 提升 |
|------|----------|----------|------|
| 通用问答 | 78% | 86% | +8% |
| 专业文档 | 72% | 89% | +17% |
| 长尾查询 | 65% | 81% | +16% |

---

## 六、生产环境优化

### 6.1 优化技巧

| 优化项 | 效果 | 难度 | 推荐度 |
|--------|------|------|--------|
| 语义切分 | 准确率+10-15% | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| 混合检索 | 准确率+5-10% | ⭐⭐ | ⭐⭐⭐⭐⭐ |
| Rerank | 准确率+8-17% | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| 查询缓存 | 延迟-50% | ⭐⭐ | ⭐⭐⭐⭐ |

### 6.2 查询缓存实现

```python
import hashlib

def cached_search(query):
    query_hash = hashlib.md5(query.encode()).hexdigest()

    if cache.exists(query_hash):
        return cache.get(query_hash)

    results = vector_search(query)
    cache.set(query_hash, results, ttl=3600)

    return results
```

### 6.3 监控指标

| 指标 | 目标值 | 说明 |
|------|--------|------|
| **检索准确率** | >85% | Top-5相关度 |
| **检索延迟** | <100ms | P95延迟 |
| **召回率** | >90% | 相关文档召回比例 |
| **缓存命中率** | >30% | 缓存效果 |

---

## 七、总结

### 7.1 核心要点

1. **切分是基础**
   - 语义切分 > 固定长度切分
   - 保持文档结构完整性
   - 设置合理的overlap

2. **元数据是加速器**
   - 核心字段：source, title, chapter
   - 实用字段：date, tags, category
   - 支持过滤和排序

3. **检索策略演进**
   - Top-K → 混合检索 → Rerank
   - 混合检索：向量+关键词
   - Rerank：粗排+精排

4. **生产优化**
   - 查询缓存降低延迟
   - 分级检索提升效率
   - 监控指标持续优化

### 7.2 最佳实践清单

```
✅ 优先使用语义切分
✅ 设置合理的overlap（50-200字符）
✅ 添加丰富的元数据
✅ 使用混合检索（向量+关键词）
✅ 应用Rerank重排序
✅ 实现查询缓存
✅ 监控关键指标
❌ 避免在句子中间切分
❌ 避免chunk过大或过小
```

### 7.3 性能对比

| 方法 | 准确率 | 实施难度 |
|------|--------|---------|
| 基础Top-K | 78% | ⭐ |
| +混合检索 | 88% | ⭐⭐ |
| +Rerank | 95% | ⭐⭐⭐ |
| +元数据过滤 | 96% | ⭐⭐⭐ |
| +查询缓存 | 96% (延迟-50%) | ⭐⭐⭐ |

---

## 参考资源

### 开源库
- LangChain Text Splitters: https://python.langchain.com/docs/modules/data_connection/document_transformers/
- LlamaIndex Node Parsers: https://docs.llamaindex.ai/en/stable/module_guides/loading/node_parsers/

### Rerank模型
- BGE-reranker: https://github.com/FlagOpen/FlagEmbedding
- Cohere Rerank: https://docs.cohere.com/docs/rerank-2

---

**版权声明：** 本文原创内容，转载请注明出处。

**作者：** 架构狮与橘
**发布时间：** 2025年1月
**系列：** RAG深度解析系列 第03期

---

> 💡 **下一期预告：** 《RAG质量优化实战》
